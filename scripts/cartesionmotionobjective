#!/usr/bin/env python

'''
Send a Cartesian Motion Objective

Usage:
  cartesionmotionobjective left  <x> <y> <z> [<roll> <pitch> <yaw>]
  cartesionmotionobjective right <x> <y> <z> [<roll> <pitch> <yaw>]
  cartesionmotionobjective cancel
  cartesionmotionobjective -h | --help

Options:
  -h --help     Show this screen.
'''

from docopt import docopt
import roslib; roslib.load_manifest('amigo_whole_body_controller')
import rospy
import actionlib

from amigo_whole_body_controller.msg import *
from arm_navigation_msgs.msg import *
from tf.transformations import quaternion_from_euler

def euler_z_to_orientation_goal(orientation):
    roll  = orientation['roll']  or 0
    pitch = orientation['pitch'] or 0
    yaw   = orientation['yaw']   or 0

    q = geometry_msgs.msg.Quaternion(*quaternion_from_euler(roll, pitch, yaw))

    # header,link_name,type,orientation,
    # absolute_roll_tolerance,absolute_pitch_tolerance,absolute_yaw_tolerance
    # weight

    return OrientationConstraint(
        orientation=q)

class CartesianMotionObjective():

    link_name = "grippoint_right"
    stiffnessfactor = 4.0

    def __init__(self):
        self.stiffness   = {
                'force': (
                        70.0 * self.stiffnessfactor,
                        70.0 * self.stiffnessfactor,
                        50.0 * self.stiffnessfactor),
                'torque': (
                        0.0 * self.stiffnessfactor,
                        0.0 * self.stiffnessfactor,
                        0.0 * self.stiffnessfactor) }

        self.action_client = actionlib.SimpleActionClient("add_motion_objective", ArmTaskAction)
        self.action_client.feedback_cb = self.feedback_cb

        self.action_client.wait_for_server()
        rospy.loginfo("Connected to action server")

    def build_goal(self, position, orientation):
        self.position    = position
        orientation_goal = euler_z_to_orientation_goal(orientation)

        position_constraint = PositionConstraint(
            header=std_msgs.msg.Header(frame_id='base_link'),
            link_name=self.link_name,
            position=geometry_msgs.msg.Point(*self.position))

        stiffness = geometry_msgs.msg.Wrench(
            force=geometry_msgs.msg.Vector3(*self.stiffness['force']),
            torque=geometry_msgs.msg.Vector3(*self.stiffness['torque']))

        goal = ArmTaskGoal(
            goal_type='grasp',
            position_constraint=position_constraint,
            orientation_constraint=orientation_goal,
            stiffness=stiffness)
        return goal

    def send_goal(self, goal):
        rospy.loginfo("Sending goal...")
        print goal

        rospy.loginfo("Waiting for result...")
        self.action_client.send_goal(goal)

    def wait_for_result(self):
        finished = False
        try:
            finished = self.action_client.wait_for_result()
        except KeyboardInterrupt:
            print "Canceling goal..."
            self.action_client.cancel_goal()
            self.action_client.wait_for_result(rospy.Duration(0.5))
        if not finished:
            return

        rospy.loginfo("Result!")
        result = self.action_client.get_result()
        print result

    def feedback_cb(self):
        print 'feedback!!!'
        pass

if __name__ == '__main__':
    arguments = docopt(__doc__, options_first=True)
    print(arguments)

    try:
        # disable signals so we can detect a KeyboardInterrupt
        rospy.init_node('add_motion_objective', disable_signals=True)

        if arguments['cancel']:
            cmo = CartesianMotionObjective()
            cmo.action_client.cancel_all_goals()
            cmo.action_client.wait_for_server()

        elif arguments['left'] or arguments['right']:
            position = (
                float(arguments['<x>']),
                float(arguments['<y>']),
                float(arguments['<z>']))
            orientation = {
                'roll' : arguments['<roll>' ] ,
                'pitch': arguments['<pitch>'] ,
                'yaw'  : arguments['<yaw>'  ] }

            cmo = CartesianMotionObjective()
            cmo.send_goal(cmo.build_goal(position, orientation))
            cmo.wait_for_result()

    except KeyboardInterrupt:
        print "program interrupted before completion"
