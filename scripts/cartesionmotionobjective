#!/usr/bin/env python

'''
Send a Cartesian Motion Objective

Usage:
  cartesionmotionobjective send <x> <y> <z> [<roll> <pitch> <yaw>]
  cartesionmotionobjective -h | --help

Options:
  -h --help     Show this screen.
'''

from docopt import docopt
import roslib; roslib.load_manifest('amigo_whole_body_controller')
import rospy
import actionlib

from amigo_whole_body_controller.msg import *
from arm_navigation_msgs.msg import *
from tf.transformations import quaternion_from_euler
'''
ArmTaskAction
ArmTaskActionFeedback
ArmTaskActionGoal
ArmTaskActionResult
ArmTaskFeedback
ArmTaskGoal
ArmTaskResult
WholeBodyControllerStatus
'''

def euler_z_to_orientation_goal(orientation):
    roll  = orientation['roll']  or 0
    pitch = orientation['pitch'] or 0
    yaw   = orientation['yaw']   or 0

    q = geometry_msgs.msg.Quaternion(*quaternion_from_euler(roll, pitch, yaw))

    # header,link_name,type,orientation,
    # absolute_roll_tolerance,absolute_pitch_tolerance,absolute_yaw_tolerance
    # weight

    return OrientationConstraint(
        orientation=q)

class CartesianMotionObjective():

    link_name = "grippoint_right"
    stiffnessfactor = 4.0

    def __init__(self, position, orientation, stiffness=None):
        if not stiffness:
            stiffness = {
                'force': (
                        70.0 * self.stiffnessfactor,
                        70.0 * self.stiffnessfactor,
                        50.0 * self.stiffnessfactor),
                'torque': (
                        0.0 * self.stiffnessfactor,
                        0.0 * self.stiffnessfactor,
                        0.0 * self.stiffnessfactor) }
        self.stiffness   = stiffness
        self.position    = position
        self.orientation = euler_z_to_orientation_goal(orientation)

        self.action_client = actionlib.SimpleActionClient("add_motion_objective", ArmTaskAction)
        self.action_client.feedback_cb = self.feedback_cb

        self.action_client.wait_for_server()
        rospy.loginfo("Connected to action server")

    def send_goal_and_wait(self):
        rospy.loginfo("Sending goal...")

        position_constraint = PositionConstraint(
            header=std_msgs.msg.Header(frame_id='base_link'),
            link_name=self.link_name,
            position=geometry_msgs.msg.Point(*self.position))

        stiffness = geometry_msgs.msg.Wrench(
            force=geometry_msgs.msg.Vector3(*self.stiffness['force']),
            torque=geometry_msgs.msg.Vector3(*self.stiffness['torque']))

        goal = ArmTaskGoal(
            goal_type='grasp',
            position_constraint=position_constraint,
            orientation_constraint=self.orientation,
            stiffness=stiffness)

        #goal = ArmTaskGoal()
        print goal

        rospy.loginfo("Waiting for result...")

        self.action_client.send_goal(goal)

        finished = False
        try:
            finished = self.action_client.wait_for_result()
        except KeyboardInterrupt:
            print "Canceling goal..."
            self.action_client.cancel_goal()
            self.action_client.wait_for_result(rospy.Duration(0.5))

        if not finished:
            return

        rospy.loginfo("Result!")
        result = self.action_client.get_result()
        print result

    def feedback_cb(self):
        print 'feedback!!!'
        pass

if __name__ == '__main__':
    arguments = docopt(__doc__, options_first=True)
    print(arguments)

    position = (
        float(arguments['<x>']),
        float(arguments['<y>']),
        float(arguments['<z>']))
    orientation = {
        'roll' : arguments['<roll>' ] ,
        'pitch': arguments['<pitch>'] ,
        'yaw'  : arguments['<yaw>'  ] }

    try:
        # disable signals so we can detect a KeyboardInterrupt
        rospy.init_node('add_motion_objective', disable_signals=True)

        cmo = CartesianMotionObjective(position, orientation)
        cmo.send_goal_and_wait()

    except rospy.ROSInterruptException:
        print "program interrupted before completion"
